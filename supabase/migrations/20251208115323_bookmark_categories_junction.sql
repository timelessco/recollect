-- ============================================================================
-- MIGRATION: Create bookmark_categories junction table for many-to-many
-- Created: 2024-12-08
-- Purpose: Enable bookmarks to belong to multiple categories
-- Phase: 1a (Staged migration - keeps category_id column for backward compatibility)
-- ============================================================================

BEGIN;

-- Pre-flight validation: Ensure category_id=0 exists for uncategorized bookmarks
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.categories WHERE id = 0) THEN
        RAISE EXCEPTION 'Migration blocked: category with id=0 does not exist. Run seed migration first.';
    END IF;
END $$;

-- 1. Create junction table
CREATE TABLE IF NOT EXISTS public.bookmark_categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bookmark_id bigint NOT NULL,
    category_id bigint NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    CONSTRAINT bookmark_categories_bookmark_id_fkey
        FOREIGN KEY (bookmark_id) REFERENCES public.everything(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_category_id_fkey
        FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE RESTRICT,
    CONSTRAINT bookmark_categories_user_id_fkey
        FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_unique UNIQUE (bookmark_id, category_id)
);

-- 2. Create indexes for query performance
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_bookmark_id ON public.bookmark_categories(bookmark_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_category_id ON public.bookmark_categories(category_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_id ON public.bookmark_categories(user_id);
-- Composite index for common query patterns
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_category ON public.bookmark_categories(user_id, category_id);

-- 3. Enable RLS
ALTER TABLE public.bookmark_categories ENABLE ROW LEVEL SECURITY;

-- Grant permissions
GRANT SELECT ON TABLE public.bookmark_categories TO anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.bookmark_categories TO authenticated;

-- 4. RLS policies (matching everything table pattern for shared/public access)

-- SELECT: Authenticated users can view bookmark_categories if:
-- 1. They own the entry (user_id = auth.uid())
-- 2. They are a collaborator in the category (via shared_categories)
-- 3. They own the category (category owner sees all)
CREATE POLICY "bookmark_categories_select_authenticated"
ON public.bookmark_categories FOR SELECT TO authenticated
USING (
    -- User owns this bookmark_category entry
    user_id = (SELECT auth.uid())
    OR
    -- User is a collaborator in this category
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
    )
    OR
    -- User owns the category
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE user_id = (SELECT auth.uid())
    )
);

-- SELECT: Anonymous users can view bookmark_categories for public categories
CREATE POLICY "bookmark_categories_select_public"
ON public.bookmark_categories FOR SELECT TO anon
USING (
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE is_public = true
    )
);

-- INSERT: Users can only insert bookmark_categories for bookmarks they own
CREATE POLICY "bookmark_categories_insert"
ON public.bookmark_categories FOR INSERT TO authenticated
WITH CHECK (
    user_id = (SELECT auth.uid())
    AND
    -- User MUST own the bookmark they're adding
    bookmark_id IN (SELECT id FROM public.everything WHERE user_id = (SELECT auth.uid()))
);

-- DELETE: Users can delete bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category
CREATE POLICY "bookmark_categories_delete"
ON public.bookmark_categories FOR DELETE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
);

-- UPDATE: Users can update bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category
CREATE POLICY "bookmark_categories_update"
ON public.bookmark_categories FOR UPDATE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
)
WITH CHECK (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
);

-- 5. Migrate existing data from everything.category_id to junction table
-- This preserves the current one-to-one relationship as entries in the junction table
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, e.category_id, e.user_id, e.inserted_at
FROM public.everything e
WHERE e.category_id IS NOT NULL AND e.category_id != 0
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Handle uncategorized bookmarks (category_id = 0 or NULL) by creating entry with category_id = 0
-- Note: This requires a "default" category with id=0 to exist, or we skip uncategorized for now
-- For safety, we only migrate bookmarks that have a valid category_id pointing to existing categories
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, 0, e.user_id, e.inserted_at
FROM public.everything e
WHERE e.category_id IS NULL OR e.category_id = 0
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Documentation
COMMENT ON TABLE public.bookmark_categories IS
'Junction table for many-to-many relationship between bookmarks (everything) and categories. Allows bookmarks to belong to multiple categories. category_id = 0 represents uncategorized bookmarks.';

COMMENT ON COLUMN public.bookmark_categories.bookmark_id IS 'Foreign key to everything.id (bookmark)';
COMMENT ON COLUMN public.bookmark_categories.category_id IS 'Foreign key to categories.id. 0 = uncategorized';
COMMENT ON COLUMN public.bookmark_categories.user_id IS 'Owner of this bookmark-category association';

-- ============================================================================
-- NOTE: The category_id column in the everything table is intentionally kept
-- for backward compatibility. It will be dropped in a future migration after
-- all application code has been updated to use the junction table.
-- ============================================================================

-- Post-migration verification
DO $$
DECLARE
    v_everything_count bigint;
    v_junction_count bigint;
BEGIN
    SELECT COUNT(*) INTO v_everything_count FROM public.everything;
    SELECT COUNT(*) INTO v_junction_count FROM public.bookmark_categories;

    IF v_everything_count != v_junction_count THEN
        RAISE EXCEPTION 'Data mismatch: % bookmarks but % junction entries. Rolling back.',
            v_everything_count, v_junction_count;
    END IF;

    RAISE NOTICE 'Migration verified: % rows migrated successfully', v_junction_count;
END $$;

COMMIT;
