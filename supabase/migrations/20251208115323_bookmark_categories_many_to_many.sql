-- ============================================================================
-- MIGRATION: Implement many-to-many bookmark categories relationship
-- Created: 2025-12-08
-- Purpose: Enable bookmarks to belong to multiple categories via junction table
-- ============================================================================
--
-- This migration:
--   1. Creates bookmark_categories junction table with RLS policies
--   2. Migrates existing data from everything.category_id
--   3. Protects category_id=0 (Uncategorized) from deletion via trigger
--   4. Creates set_bookmark_categories RPC with FOR UPDATE locking
--   5. Updates search_bookmarks_url_tag_scope RPC (CTEs to avoid N+1)
--   6. Drops deprecated category_id column from everything table
--
-- ============================================================================

BEGIN;

-- ============================================================================
-- PART 1: Create junction table
-- ============================================================================

-- Pre-flight validation: Ensure category_id=0 exists for uncategorized bookmarks
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.categories WHERE id = 0) THEN
        RAISE EXCEPTION 'Migration blocked: category with id=0 does not exist. Run seed migration first.';
    END IF;
END $$;

-- 1. Create junction table
CREATE TABLE IF NOT EXISTS public.bookmark_categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bookmark_id bigint NOT NULL,
    category_id bigint NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    CONSTRAINT bookmark_categories_bookmark_id_fkey
        FOREIGN KEY (bookmark_id) REFERENCES public.everything(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_category_id_fkey
        FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE RESTRICT,
    CONSTRAINT bookmark_categories_user_id_fkey
        FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_unique UNIQUE (bookmark_id, category_id)
);

-- 2. Create indexes for query performance
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_bookmark_id ON public.bookmark_categories(bookmark_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_category_id ON public.bookmark_categories(category_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_id ON public.bookmark_categories(user_id);
-- Composite indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_category ON public.bookmark_categories(user_id, category_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_bookmark_user ON public.bookmark_categories(bookmark_id, user_id);

-- Indexes for columns referenced in RLS policies (performance optimization)
CREATE INDEX IF NOT EXISTS idx_categories_is_public ON public.categories(is_public);
CREATE INDEX IF NOT EXISTS idx_shared_categories_edit_access ON public.shared_categories(edit_access);

-- 3. Enable RLS
ALTER TABLE public.bookmark_categories ENABLE ROW LEVEL SECURITY;

-- Grant permissions
GRANT SELECT ON TABLE public.bookmark_categories TO anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.bookmark_categories TO authenticated;

-- 4. Helper function to check bookmark ownership (bypasses RLS to prevent recursion)
-- This is the Supabase-recommended pattern for breaking circular RLS dependencies
-- SECURITY: Function only checks ownership for the calling user (p_user_id must equal auth.uid())
-- This prevents enumeration attacks where users could check arbitrary user_id values
CREATE OR REPLACE FUNCTION public.user_owns_bookmark(p_bookmark_id bigint, p_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
STABLE
AS $$
BEGIN
    -- SECURITY: Only allow checking ownership for the calling user
    -- This prevents enumeration attacks (cannot check other users' bookmark ownership)
    IF p_user_id IS DISTINCT FROM auth.uid() THEN
        RETURN false;
    END IF;

    RETURN EXISTS (
        SELECT 1 FROM public.everything
        WHERE id = p_bookmark_id AND user_id = p_user_id
    );
END;
$$;

-- Grant EXECUTE to authenticated users (needed for RLS policies)
-- Security is enforced inside the function by checking p_user_id = auth.uid()
GRANT EXECUTE ON FUNCTION public.user_owns_bookmark(bigint, uuid) TO authenticated;

COMMENT ON FUNCTION public.user_owns_bookmark(bigint, uuid) IS
'Helper function to check if a user owns a bookmark. Uses SECURITY DEFINER to bypass RLS and prevent infinite recursion in bookmark_categories policies. Function enforces that p_user_id must equal auth.uid() to prevent enumeration attacks.';

-- 5. RLS policies (matching everything table pattern for shared/public access)

-- SELECT: Authenticated users can view bookmark_categories if:
-- 1. They own the entry (user_id = auth.uid())
-- 2. They are a collaborator in the category (via shared_categories)
-- 3. They own the category (category owner sees all)
CREATE POLICY "bookmark_categories_select_authenticated"
ON public.bookmark_categories FOR SELECT TO authenticated
USING (
    -- User owns this bookmark_category entry
    user_id = (SELECT auth.uid())
    OR
    -- User is a collaborator in this category
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
    )
    OR
    -- User owns the category
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE user_id = (SELECT auth.uid())
    )
);

-- SELECT: Anonymous users can view bookmark_categories for public categories
CREATE POLICY "bookmark_categories_select_public"
ON public.bookmark_categories FOR SELECT TO anon
USING (
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE is_public = true
    )
);

-- INSERT: Users can only insert bookmark_categories for bookmarks they own
CREATE POLICY "bookmark_categories_insert"
ON public.bookmark_categories FOR INSERT TO authenticated
WITH CHECK (
    user_id = (SELECT auth.uid())
    AND
    -- Use SECURITY DEFINER function to check bookmark ownership without triggering RLS recursion
    public.user_owns_bookmark(bookmark_id, (SELECT auth.uid()))
);

-- DELETE: Users can delete bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category AND own the bookmark
CREATE POLICY "bookmark_categories_delete"
ON public.bookmark_categories FOR DELETE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    (
        category_id IN (
            SELECT category_id
            FROM public.shared_categories
            WHERE email = (SELECT auth.jwt()->>'email')
            AND edit_access = true
        )
        AND
        public.user_owns_bookmark(bookmark_id, (SELECT auth.uid()))
    )
);

-- UPDATE: Users can update bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category AND own the bookmark
CREATE POLICY "bookmark_categories_update"
ON public.bookmark_categories FOR UPDATE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    (
        category_id IN (
            SELECT category_id
            FROM public.shared_categories
            WHERE email = (SELECT auth.jwt()->>'email')
            AND edit_access = true
        )
        AND
        public.user_owns_bookmark(bookmark_id, (SELECT auth.uid()))
    )
)
WITH CHECK (
    user_id = (SELECT auth.uid())
    OR
    (
        category_id IN (
            SELECT category_id
            FROM public.shared_categories
            WHERE email = (SELECT auth.jwt()->>'email')
            AND edit_access = true
        )
        AND
        public.user_owns_bookmark(bookmark_id, (SELECT auth.uid()))
    )
);

-- 6. Migrate existing data from everything.category_id to junction table
-- EXCLUSIVE MODEL: A bookmark has EITHER category 0 OR real categories, never both
-- Category 0 is auto-managed by the backend and cannot be manually assigned by users

-- Step 1: Migrate bookmarks with real categories (NOT 0)
-- These bookmarks will NOT have category 0 in the junction table
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, e.category_id, e.user_id, e.inserted_at
FROM public.everything e
WHERE e.category_id IS NOT NULL AND e.category_id != 0
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Step 2: Add category 0 ONLY for bookmarks that have NO entry yet (truly uncategorized)
-- This ensures bookmarks with real categories don't also get category 0
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, 0, e.user_id, e.inserted_at
FROM public.everything e
WHERE NOT EXISTS (
    SELECT 1 FROM public.bookmark_categories bc WHERE bc.bookmark_id = e.id
)
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Documentation
COMMENT ON TABLE public.bookmark_categories IS
'Junction table for many-to-many relationship between bookmarks (everything) and categories. Allows bookmarks to belong to multiple categories. category_id = 0 represents uncategorized bookmarks.';

COMMENT ON COLUMN public.bookmark_categories.bookmark_id IS 'Foreign key to everything.id (bookmark)';
COMMENT ON COLUMN public.bookmark_categories.category_id IS 'Foreign key to categories.id. 0 = uncategorized';
COMMENT ON COLUMN public.bookmark_categories.user_id IS 'Owner of this bookmark-category association';

-- Post-migration verification for Part 1
DO $$
DECLARE
    v_everything_count bigint;
    v_junction_bookmark_count bigint;
BEGIN
    SELECT COUNT(*) INTO v_everything_count FROM public.everything;
    SELECT COUNT(DISTINCT bookmark_id) INTO v_junction_bookmark_count FROM public.bookmark_categories;

    IF v_everything_count != v_junction_bookmark_count THEN
        RAISE EXCEPTION 'Data mismatch: % bookmarks but only % have junction entries. Rolling back.',
            v_everything_count, v_junction_bookmark_count;
    END IF;

    RAISE NOTICE 'Junction table migration verified: all % bookmarks have junction entries', v_everything_count;
END $$;

-- 7. Protect category_id=0 from deletion
CREATE OR REPLACE FUNCTION public.prevent_uncategorized_category_deletion()
RETURNS TRIGGER
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
BEGIN
    IF OLD.id = 0 THEN
        RAISE EXCEPTION 'Cannot delete the Uncategorized category (id=0). This is a protected system category.';
    END IF;
    RETURN OLD;
END;
$$;

COMMENT ON FUNCTION public.prevent_uncategorized_category_deletion() IS
'Prevents deletion of the Uncategorized category (id=0).';

DROP TRIGGER IF EXISTS prevent_category_zero_deletion ON public.categories;

CREATE TRIGGER prevent_category_zero_deletion
BEFORE DELETE ON public.categories
FOR EACH ROW
EXECUTE FUNCTION public.prevent_uncategorized_category_deletion();

-- ============================================================================
-- PART 2: Create set_bookmark_categories RPC function
-- ============================================================================

-- Atomic function to replace bookmark categories
-- EXCLUSIVE MODEL: Bookmark has EITHER category 0 OR real categories, never both
CREATE OR REPLACE FUNCTION public.set_bookmark_categories(
  p_bookmark_id bigint,
  p_category_ids bigint[]
)
RETURNS SETOF public.bookmark_categories
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_user_id uuid := (SELECT auth.uid());
  v_category_ids bigint[];
  v_non_zero_ids bigint[];
BEGIN
  -- Filter out category 0 from input (users cannot manually assign to 0)
  v_non_zero_ids := ARRAY(
    SELECT unnest(p_category_ids)
    WHERE unnest != 0
  );

  -- EXCLUSIVE logic: If no real categories, use only 0. Otherwise, use only real categories.
  IF array_length(v_non_zero_ids, 1) IS NULL OR array_length(v_non_zero_ids, 1) = 0 THEN
    v_category_ids := ARRAY[0::bigint];
  ELSE
    v_category_ids := v_non_zero_ids;
  END IF;

  -- Remove duplicates
  v_category_ids := ARRAY(SELECT DISTINCT unnest(v_category_ids));

  -- Lock the bookmark row to prevent race conditions
  -- This ensures atomic updates when multiple requests try to modify categories
  PERFORM 1 FROM public.everything
  WHERE id = p_bookmark_id AND user_id = v_user_id
  FOR UPDATE;

  -- Delete existing entries for this bookmark/user
  DELETE FROM public.bookmark_categories
  WHERE bookmark_id = p_bookmark_id AND user_id = v_user_id;

  -- Insert new entries and return them
  RETURN QUERY
  INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id)
  SELECT p_bookmark_id, unnest(v_category_ids), v_user_id
  RETURNING *;
END;
$$;

-- Set permissions (only authenticated users can call)
REVOKE EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) FROM anon;
GRANT EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) TO authenticated;

COMMENT ON FUNCTION public.set_bookmark_categories IS
'Atomically replaces all category associations for a bookmark. Uses FOR UPDATE locking to prevent race conditions. Deletes existing entries and inserts new ones in a single transaction.';

-- Bulk add: Add single category to multiple bookmarks
-- EXCLUSIVE MODEL: When adding a real category, remove category 0 first
CREATE OR REPLACE FUNCTION public.add_category_to_bookmarks(
    p_bookmark_ids bigint[],
    p_category_id bigint
)
RETURNS TABLE(out_bookmark_id bigint, out_category_id bigint)
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp
AS $$
DECLARE
    v_user_id uuid := (SELECT auth.uid());
BEGIN
    -- Lock the bookmark rows to prevent race conditions
    -- This ensures atomic updates when multiple requests try to modify categories
    PERFORM 1 FROM public.everything
    WHERE id = ANY(p_bookmark_ids) AND user_id = v_user_id
    FOR UPDATE;

    -- EXCLUSIVE logic: When adding a non-0 category, remove category 0 from these bookmarks
    IF p_category_id != 0 THEN
        DELETE FROM public.bookmark_categories
        WHERE bookmark_id = ANY(p_bookmark_ids)
          AND category_id = 0
          AND user_id = v_user_id;
    END IF;

    -- Insert the new category association
    RETURN QUERY
    INSERT INTO public.bookmark_categories AS bc (bookmark_id, category_id, user_id)
    SELECT unnest(p_bookmark_ids), p_category_id, v_user_id
    ON CONFLICT (bookmark_id, category_id) DO NOTHING
    RETURNING bc.bookmark_id, bc.category_id;
END;
$$;

REVOKE EXECUTE ON FUNCTION public.add_category_to_bookmarks(bigint[], bigint) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.add_category_to_bookmarks(bigint[], bigint) FROM anon;
GRANT EXECUTE ON FUNCTION public.add_category_to_bookmarks(bigint[], bigint) TO authenticated;

COMMENT ON FUNCTION public.add_category_to_bookmarks IS
'Adds a single category to multiple bookmarks atomically. Uses FOR UPDATE locking to prevent race conditions. Uses ON CONFLICT DO NOTHING to skip existing associations. Removes category 0 when adding a real category (exclusive model).';

-- Remove category from bookmark with auto-add of category 0 when last real category removed
-- EXCLUSIVE MODEL: Auto-adds 0 when no real categories remain
CREATE OR REPLACE FUNCTION public.remove_category_from_bookmark(
    p_bookmark_id bigint,
    p_category_id bigint
)
RETURNS TABLE(deleted_category_id bigint, added_uncategorized boolean)
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp
AS $$
DECLARE
    v_user_id uuid := (SELECT auth.uid());
    v_remaining_non_zero_count int;
    v_deleted boolean := false;
BEGIN
    -- Lock the bookmark row to prevent race conditions
    -- This ensures atomic updates when multiple requests try to modify categories
    PERFORM 1 FROM public.everything
    WHERE id = p_bookmark_id AND user_id = v_user_id
    FOR UPDATE;

    -- Cannot manually remove category 0 (it's auto-managed)
    IF p_category_id = 0 THEN
        RAISE EXCEPTION 'Cannot manually remove uncategorized category. Add a real category instead.';
    END IF;

    -- Delete the specified category
    DELETE FROM public.bookmark_categories
    WHERE bookmark_id = p_bookmark_id
      AND category_id = p_category_id
      AND user_id = v_user_id;

    -- Check if delete was successful
    IF FOUND THEN
        v_deleted := true;
    END IF;

    -- Check remaining non-0 categories
    SELECT COUNT(*) INTO v_remaining_non_zero_count
    FROM public.bookmark_categories
    WHERE bookmark_id = p_bookmark_id
      AND category_id != 0
      AND user_id = v_user_id;

    -- EXCLUSIVE logic: If no non-0 categories remain, auto-add 0
    IF v_remaining_non_zero_count = 0 THEN
        INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id)
        VALUES (p_bookmark_id, 0, v_user_id)
        ON CONFLICT (bookmark_id, category_id) DO NOTHING;

        RETURN QUERY SELECT p_category_id, true;
    ELSE
        RETURN QUERY SELECT p_category_id, false;
    END IF;
END;
$$;

REVOKE EXECUTE ON FUNCTION public.remove_category_from_bookmark(bigint, bigint) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.remove_category_from_bookmark(bigint, bigint) FROM anon;
GRANT EXECUTE ON FUNCTION public.remove_category_from_bookmark(bigint, bigint) TO authenticated;

COMMENT ON FUNCTION public.remove_category_from_bookmark IS
'Removes a category from a bookmark. Uses FOR UPDATE locking to prevent race conditions. Auto-adds category 0 when last non-0 category is removed (exclusive model). Cannot manually remove category 0.';

-- ============================================================================
-- PART 3: Update search RPC for junction table queries (optimized with CTEs)
-- ============================================================================

SET check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.search_bookmarks_url_tag_scope(
    search_text character varying DEFAULT '',
    url_scope character varying DEFAULT '',
    tag_scope text[] DEFAULT NULL,
    category_scope bigint DEFAULT NULL
)
RETURNS TABLE(
    id bigint,
    user_id uuid,
    inserted_at timestamp with time zone,
    title extensions.citext,
    url text,
    description text,
    ogimage text,
    screenshot text,
    trash boolean,
    type text,
    meta_data jsonb,
    sort_index text,
    added_tags jsonb,
    added_categories jsonb,
    make_discoverable timestamp with time zone
)
LANGUAGE plpgsql
VOLATILE
SECURITY INVOKER
SET search_path = public, extensions
AS $function$
BEGIN
    SET LOCAL pg_trgm.similarity_threshold = 0.6;

    RETURN QUERY
    WITH
    -- Pre-aggregate tags (single pass, avoids N+1)
    bookmark_tags_agg AS (
        SELECT
            bt.bookmark_id,
            bt.user_id,
            jsonb_agg(jsonb_build_object('id', t.id, 'name', t.name)) AS tags_json
        FROM public.bookmark_tags bt
        JOIN public.tags t ON t.id = bt.tag_id
        GROUP BY bt.bookmark_id, bt.user_id
    ),
    -- Pre-aggregate categories (single pass, avoids N+1)
    bookmark_cats_agg AS (
        SELECT
            bc.bookmark_id,
            bc.user_id,
            jsonb_agg(
                jsonb_build_object(
                    'id', c.id,
                    'category_name', c.category_name,
                    'category_slug', c.category_slug,
                    'icon', c.icon,
                    'icon_color', c.icon_color
                )
                ORDER BY bc.created_at ASC
            ) AS categories_json
        FROM public.bookmark_categories bc
        JOIN public.categories c ON c.id = bc.category_id
        GROUP BY bc.bookmark_id, bc.user_id
    )
    SELECT
        b.id,
        b.user_id,
        b.inserted_at,
        b.title,
        b.url,
        b.description,
        b."ogImage",
        b.screenshot,
        b.trash,
        b.type,
        b.meta_data,
        b.sort_index,
        COALESCE(bta.tags_json, '[]'::jsonb) AS added_tags,
        COALESCE(bca.categories_json, '[]'::jsonb) AS added_categories,
        b.make_discoverable
    FROM public.everything b
    LEFT JOIN bookmark_tags_agg bta ON bta.bookmark_id = b.id AND bta.user_id = b.user_id
    LEFT JOIN bookmark_cats_agg bca ON bca.bookmark_id = b.id AND bca.user_id = b.user_id
    WHERE
        -- URL scope filter (optional)
        (
            url_scope IS NULL
            OR url_scope = ''
            OR b.url ILIKE '%' || url_scope || '%'
        )

        AND
        -- Tag scope filter (optional, supports multiple tags with AND logic)
        (
            tag_scope IS NULL
            OR array_length(tag_scope, 1) IS NULL
            OR (
                SELECT COUNT(DISTINCT LOWER(t.name))
                FROM public.bookmark_tags bt
                JOIN public.tags t ON t.id = bt.tag_id
                WHERE bt.bookmark_id = b.id
                  AND LOWER(t.name) = ANY(
                      SELECT LOWER(unnest(tag_scope))
                  )
            ) = array_length(tag_scope, 1)  -- Must match ALL searched tags (AND logic)
        )

        AND
        -- Category scope filter via junction table (optional)
        (
            category_scope IS NULL
            OR EXISTS (
                SELECT 1
                FROM public.bookmark_categories bc
                WHERE bc.bookmark_id = b.id
                  AND bc.category_id = category_scope
            )
        )

        AND
        -- Main search_text logic (optional)
        (
            search_text IS NULL
            OR search_text = ''
            OR (
                search_text % ANY(STRING_TO_ARRAY(COALESCE(b.title::text, '') || ' ' || COALESCE(b.description, ''), ' '))
                OR b.url ILIKE '%' || search_text || '%'
                OR EXISTS (
                    SELECT 1
                    FROM jsonb_each_text(COALESCE(b.meta_data, '{}'::jsonb)) AS x(key, value)
                    WHERE key IN ('img_caption', 'ocr')
                      AND value ILIKE '%' || search_text || '%'
                )
            )
        )

    ORDER BY
        CASE
            WHEN search_text IS NULL OR search_text = '' THEN 0
            ELSE (
                similarity(COALESCE(b.url, ''), search_text) * 0.6 +
                similarity(COALESCE(b.title::text, ''), search_text) * 0.5 +
                similarity(COALESCE(b.description, ''), search_text) * 0.3 +
                similarity(COALESCE(b.meta_data->>'ocr', ''), search_text) * 0.1 +
                similarity(COALESCE(b.meta_data->>'img_caption', ''), search_text) * 0.15
            )
        END DESC,
        b.inserted_at DESC;
END;
$function$;

COMMENT ON FUNCTION public.search_bookmarks_url_tag_scope(character varying, character varying, text[], bigint) IS
'Bookmark search with URL/tag/category filters. Uses CTEs to avoid N+1 queries when aggregating tags and categories.';

-- ============================================================================
-- PART 4: Drop deprecated category_id column from everything table
-- ============================================================================

-- 1. Drop the existing RLS policy that references category_id
DROP POLICY IF EXISTS "user_access_own_bookmarks" ON "public"."everything";

-- 2. Create new RLS policy using junction table for collaborator/owner access
CREATE POLICY "user_access_own_bookmarks"
ON "public"."everything"
FOR ALL
TO authenticated
USING (
    -- User created this bookmark
    user_id = (SELECT auth.uid())
    OR
    -- User is a collaborator in any of this bookmark's categories (via junction table)
    id IN (
        SELECT bc.bookmark_id
        FROM public.bookmark_categories bc
        INNER JOIN public.shared_categories sc ON bc.category_id = sc.category_id
        WHERE sc.email = (SELECT auth.jwt()->>'email')
    )
    OR
    -- User owns any of this bookmark's categories (via junction table)
    id IN (
        SELECT bc.bookmark_id
        FROM public.bookmark_categories bc
        INNER JOIN public.categories c ON bc.category_id = c.id
        WHERE c.user_id = (SELECT auth.uid())
    )
);

-- Update documentation
COMMENT ON POLICY "user_access_own_bookmarks" ON public.everything IS
'Allows users to access: (1) their own bookmarks, (2) all bookmarks in categories shared with them as collaborators (via junction table), (3) all bookmarks in categories they own (via junction table). Updated for many-to-many category relationship.';

-- 3. Drop index on category_id
DROP INDEX IF EXISTS idx_everything_category_id;

-- 4. Drop foreign key constraints
ALTER TABLE public.everything DROP CONSTRAINT IF EXISTS bookmarks_category_id_fkey;
ALTER TABLE public.everything DROP CONSTRAINT IF EXISTS everything_category_id_fkey;

COMMIT;
