-- ============================================================================
-- MIGRATION: Implement many-to-many bookmark categories relationship
-- Created: 2024-12-08
-- Purpose: Enable bookmarks to belong to multiple categories via junction table
-- ============================================================================
--
-- This migration:
--   1. Creates bookmark_categories junction table with RLS policies
--   2. Migrates existing data from everything.category_id
--   3. Protects category_id=0 (Uncategorized) from deletion via trigger
--   4. Creates set_bookmark_categories RPC with FOR UPDATE locking
--   5. Updates search_bookmarks_url_tag_scope RPC (CTEs to avoid N+1)
--   6. Drops deprecated category_id column from everything table
--
-- ============================================================================

BEGIN;

-- ============================================================================
-- PART 1: Create junction table
-- ============================================================================

-- Pre-flight validation: Ensure category_id=0 exists for uncategorized bookmarks
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.categories WHERE id = 0) THEN
        RAISE EXCEPTION 'Migration blocked: category with id=0 does not exist. Run seed migration first.';
    END IF;
END $$;

-- 1. Create junction table
CREATE TABLE IF NOT EXISTS public.bookmark_categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bookmark_id bigint NOT NULL,
    category_id bigint NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    CONSTRAINT bookmark_categories_bookmark_id_fkey
        FOREIGN KEY (bookmark_id) REFERENCES public.everything(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_category_id_fkey
        FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE RESTRICT,
    CONSTRAINT bookmark_categories_user_id_fkey
        FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT bookmark_categories_unique UNIQUE (bookmark_id, category_id)
);

-- 2. Create indexes for query performance
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_bookmark_id ON public.bookmark_categories(bookmark_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_category_id ON public.bookmark_categories(category_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_id ON public.bookmark_categories(user_id);
-- Composite indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_user_category ON public.bookmark_categories(user_id, category_id);
CREATE INDEX IF NOT EXISTS idx_bookmark_categories_bookmark_user ON public.bookmark_categories(bookmark_id, user_id);

-- 3. Enable RLS
ALTER TABLE public.bookmark_categories ENABLE ROW LEVEL SECURITY;

-- Grant permissions
GRANT SELECT ON TABLE public.bookmark_categories TO anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.bookmark_categories TO authenticated;

-- 4. Helper function to check bookmark ownership (bypasses RLS to prevent recursion)
-- This is the Supabase-recommended pattern for breaking circular RLS dependencies
CREATE OR REPLACE FUNCTION public.user_owns_bookmark(p_bookmark_id bigint, p_user_id uuid)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public, pg_temp
STABLE
AS $$
    SELECT EXISTS (
        SELECT 1 FROM public.everything
        WHERE id = p_bookmark_id AND user_id = p_user_id
    );
$$;

GRANT EXECUTE ON FUNCTION public.user_owns_bookmark(bigint, uuid) TO authenticated;

COMMENT ON FUNCTION public.user_owns_bookmark(bigint, uuid) IS
'Helper function to check if a user owns a bookmark. Uses SECURITY DEFINER to bypass RLS and prevent infinite recursion in bookmark_categories INSERT policy.';

-- 5. RLS policies (matching everything table pattern for shared/public access)

-- SELECT: Authenticated users can view bookmark_categories if:
-- 1. They own the entry (user_id = auth.uid())
-- 2. They are a collaborator in the category (via shared_categories)
-- 3. They own the category (category owner sees all)
CREATE POLICY "bookmark_categories_select_authenticated"
ON public.bookmark_categories FOR SELECT TO authenticated
USING (
    -- User owns this bookmark_category entry
    user_id = (SELECT auth.uid())
    OR
    -- User is a collaborator in this category
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
    )
    OR
    -- User owns the category
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE user_id = (SELECT auth.uid())
    )
);

-- SELECT: Anonymous users can view bookmark_categories for public categories
CREATE POLICY "bookmark_categories_select_public"
ON public.bookmark_categories FOR SELECT TO anon
USING (
    category_id IN (
        SELECT id
        FROM public.categories
        WHERE is_public = true
    )
);

-- INSERT: Users can only insert bookmark_categories for bookmarks they own
CREATE POLICY "bookmark_categories_insert"
ON public.bookmark_categories FOR INSERT TO authenticated
WITH CHECK (
    user_id = (SELECT auth.uid())
    AND
    -- Use SECURITY DEFINER function to check bookmark ownership without triggering RLS recursion
    public.user_owns_bookmark(bookmark_id, (SELECT auth.uid()))
);

-- DELETE: Users can delete bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category
CREATE POLICY "bookmark_categories_delete"
ON public.bookmark_categories FOR DELETE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
);

-- UPDATE: Users can update bookmark_categories if:
-- 1. They own the entry
-- 2. OR they have edit_access in a shared category
CREATE POLICY "bookmark_categories_update"
ON public.bookmark_categories FOR UPDATE TO authenticated
USING (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
)
WITH CHECK (
    user_id = (SELECT auth.uid())
    OR
    category_id IN (
        SELECT category_id
        FROM public.shared_categories
        WHERE email = (SELECT auth.jwt()->>'email')
        AND edit_access = true
    )
);

-- 6. Migrate existing data from everything.category_id to junction table
-- This preserves the current one-to-one relationship as entries in the junction table
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, e.category_id, e.user_id, e.inserted_at
FROM public.everything e
WHERE e.category_id IS NOT NULL AND e.category_id != 0
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Ensure ALL bookmarks have category_id = 0 (Uncategorized) as the default base category
-- This is always present and cannot be removed via UI - only deleted when bookmark is deleted
-- This allows the UI to show "empty" selection while still maintaining database integrity
INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id, created_at)
SELECT e.id, 0, e.user_id, e.inserted_at
FROM public.everything e
ON CONFLICT (bookmark_id, category_id) DO NOTHING;

-- Documentation
COMMENT ON TABLE public.bookmark_categories IS
'Junction table for many-to-many relationship between bookmarks (everything) and categories. Allows bookmarks to belong to multiple categories. category_id = 0 represents uncategorized bookmarks.';

COMMENT ON COLUMN public.bookmark_categories.bookmark_id IS 'Foreign key to everything.id (bookmark)';
COMMENT ON COLUMN public.bookmark_categories.category_id IS 'Foreign key to categories.id. 0 = uncategorized';
COMMENT ON COLUMN public.bookmark_categories.user_id IS 'Owner of this bookmark-category association';

-- Post-migration verification for Part 1
DO $$
DECLARE
    v_everything_count bigint;
    v_junction_bookmark_count bigint;
BEGIN
    SELECT COUNT(*) INTO v_everything_count FROM public.everything;
    SELECT COUNT(DISTINCT bookmark_id) INTO v_junction_bookmark_count FROM public.bookmark_categories;

    IF v_everything_count != v_junction_bookmark_count THEN
        RAISE EXCEPTION 'Data mismatch: % bookmarks but only % have junction entries. Rolling back.',
            v_everything_count, v_junction_bookmark_count;
    END IF;

    RAISE NOTICE 'Junction table migration verified: all % bookmarks have junction entries', v_everything_count;
END $$;

-- 7. Protect category_id=0 from deletion
CREATE OR REPLACE FUNCTION public.prevent_uncategorized_category_deletion()
RETURNS TRIGGER
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
BEGIN
    IF OLD.id = 0 THEN
        RAISE EXCEPTION 'Cannot delete the Uncategorized category (id=0). This is a protected system category.';
    END IF;
    RETURN OLD;
END;
$$;

COMMENT ON FUNCTION public.prevent_uncategorized_category_deletion() IS
'Prevents deletion of the Uncategorized category (id=0).';

DROP TRIGGER IF EXISTS prevent_category_zero_deletion ON public.categories;

CREATE TRIGGER prevent_category_zero_deletion
BEFORE DELETE ON public.categories
FOR EACH ROW
EXECUTE FUNCTION public.prevent_uncategorized_category_deletion();

-- ============================================================================
-- PART 2: Create set_bookmark_categories RPC function
-- ============================================================================

-- Atomic function to replace bookmark categories
CREATE OR REPLACE FUNCTION public.set_bookmark_categories(
  p_bookmark_id bigint,
  p_category_ids bigint[]
)
RETURNS SETOF public.bookmark_categories
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_user_id uuid := (SELECT auth.uid());
  v_category_ids bigint[];
BEGIN
  -- Always include category 0 (Uncategorized) as base category
  -- This ensures every bookmark always has at least the default category
  v_category_ids := array_append(p_category_ids, 0::bigint);
  -- Remove duplicates
  v_category_ids := ARRAY(SELECT DISTINCT unnest(v_category_ids));

  -- Lock the bookmark row to prevent race conditions
  -- This ensures atomic updates when multiple requests try to modify categories
  PERFORM 1 FROM public.everything
  WHERE id = p_bookmark_id AND user_id = v_user_id
  FOR UPDATE;

  -- Delete existing entries for this bookmark/user
  DELETE FROM public.bookmark_categories
  WHERE bookmark_id = p_bookmark_id AND user_id = v_user_id;

  -- Insert new entries (always includes 0) and return them
  RETURN QUERY
  INSERT INTO public.bookmark_categories (bookmark_id, category_id, user_id)
  SELECT p_bookmark_id, unnest(v_category_ids), v_user_id
  RETURNING *;
END;
$$;

-- Set permissions (only authenticated users can call)
REVOKE EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) FROM anon;
GRANT EXECUTE ON FUNCTION public.set_bookmark_categories(bigint, bigint[]) TO authenticated;

COMMENT ON FUNCTION public.set_bookmark_categories IS
'Atomically replaces all category associations for a bookmark. Uses FOR UPDATE locking to prevent race conditions. Deletes existing entries and inserts new ones in a single transaction.';

-- ============================================================================
-- PART 3: Update search RPC for junction table queries (optimized with CTEs)
-- ============================================================================

SET check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.search_bookmarks_url_tag_scope(
    search_text character varying DEFAULT '',
    url_scope character varying DEFAULT '',
    tag_scope text[] DEFAULT NULL,
    category_scope bigint DEFAULT NULL
)
RETURNS TABLE(
    id bigint,
    user_id uuid,
    inserted_at timestamp with time zone,
    title extensions.citext,
    url text,
    description text,
    ogimage text,
    screenshot text,
    trash boolean,
    type text,
    meta_data jsonb,
    sort_index text,
    added_tags jsonb,
    added_categories jsonb
)
LANGUAGE plpgsql
VOLATILE
SECURITY INVOKER
SET search_path = public, extensions
AS $function$
BEGIN
    SET LOCAL pg_trgm.similarity_threshold = 0.6;

    RETURN QUERY
    WITH
    -- Pre-aggregate tags (single pass, avoids N+1)
    bookmark_tags_agg AS (
        SELECT
            bt.bookmark_id,
            bt.user_id,
            jsonb_agg(jsonb_build_object('id', t.id, 'name', t.name)) AS tags_json
        FROM public.bookmark_tags bt
        JOIN public.tags t ON t.id = bt.tag_id
        GROUP BY bt.bookmark_id, bt.user_id
    ),
    -- Pre-aggregate categories (single pass, avoids N+1)
    bookmark_cats_agg AS (
        SELECT
            bc.bookmark_id,
            bc.user_id,
            jsonb_agg(
                jsonb_build_object(
                    'id', c.id,
                    'category_name', c.category_name,
                    'category_slug', c.category_slug,
                    'icon', c.icon,
                    'icon_color', c.icon_color
                )
                ORDER BY bc.created_at ASC
            ) AS categories_json
        FROM public.bookmark_categories bc
        JOIN public.categories c ON c.id = bc.category_id
        GROUP BY bc.bookmark_id, bc.user_id
    )
    SELECT
        b.id,
        b.user_id,
        b.inserted_at,
        b.title,
        b.url,
        b.description,
        b.ogimage,
        b.screenshot,
        b.trash,
        b.type,
        b.meta_data,
        b.sort_index,
        COALESCE(bta.tags_json, '[]'::jsonb) AS added_tags,
        COALESCE(bca.categories_json, '[]'::jsonb) AS added_categories
    FROM public.everything b
    LEFT JOIN bookmark_tags_agg bta ON bta.bookmark_id = b.id AND bta.user_id = b.user_id
    LEFT JOIN bookmark_cats_agg bca ON bca.bookmark_id = b.id AND bca.user_id = b.user_id
    WHERE
        -- URL scope filter (optional)
        (
            url_scope IS NULL
            OR url_scope = ''
            OR b.url ILIKE '%' || url_scope || '%'
        )

        AND
        -- Tag scope filter (optional, supports multiple tags with AND logic)
        (
            tag_scope IS NULL
            OR array_length(tag_scope, 1) IS NULL
            OR (
                SELECT COUNT(DISTINCT LOWER(t.name))
                FROM public.bookmark_tags bt
                JOIN public.tags t ON t.id = bt.tag_id
                WHERE bt.bookmark_id = b.id
                  AND LOWER(t.name) = ANY(
                      SELECT LOWER(unnest(tag_scope))
                  )
            ) = array_length(tag_scope, 1)  -- Must match ALL searched tags (AND logic)
        )

        AND
        -- Category scope filter via junction table (optional)
        (
            category_scope IS NULL
            OR EXISTS (
                SELECT 1
                FROM public.bookmark_categories bc
                WHERE bc.bookmark_id = b.id
                  AND bc.category_id = category_scope
            )
        )

        AND
        -- Main search_text logic (optional)
        (
            search_text IS NULL
            OR search_text = ''
            OR (
                search_text % ANY(STRING_TO_ARRAY(COALESCE(b.title::text, '') || ' ' || COALESCE(b.description, ''), ' '))
                OR b.url ILIKE '%' || search_text || '%'
                OR EXISTS (
                    SELECT 1
                    FROM jsonb_each_text(COALESCE(b.meta_data, '{}'::jsonb)) AS x(key, value)
                    WHERE key IN ('img_caption', 'ocr')
                      AND value ILIKE '%' || search_text || '%'
                )
            )
        )

    ORDER BY
        CASE
            WHEN search_text IS NULL OR search_text = '' THEN 0
            ELSE (
                similarity(COALESCE(b.url, ''), search_text) * 0.6 +
                similarity(COALESCE(b.title::text, ''), search_text) * 0.5 +
                similarity(COALESCE(b.description, ''), search_text) * 0.3 +
                similarity(COALESCE(b.meta_data->>'ocr', ''), search_text) * 0.1 +
                similarity(COALESCE(b.meta_data->>'img_caption', ''), search_text) * 0.15
            )
        END DESC,
        b.inserted_at DESC;
END;
$function$;

COMMENT ON FUNCTION public.search_bookmarks_url_tag_scope(character varying, character varying, text[], bigint) IS
'Bookmark search with URL/tag/category filters. Uses CTEs to avoid N+1 queries when aggregating tags and categories.';

-- ============================================================================
-- PART 4: Drop deprecated category_id column from everything table
-- ============================================================================

-- 1. Drop the existing RLS policy that references category_id
DROP POLICY IF EXISTS "user_access_own_bookmarks" ON "public"."everything";

-- 2. Create new RLS policy using junction table for collaborator/owner access
CREATE POLICY "user_access_own_bookmarks"
ON "public"."everything"
FOR ALL
TO authenticated
USING (
    -- User created this bookmark
    user_id = (SELECT auth.uid())
    OR
    -- User is a collaborator in any of this bookmark's categories (via junction table)
    id IN (
        SELECT bc.bookmark_id
        FROM public.bookmark_categories bc
        INNER JOIN public.shared_categories sc ON bc.category_id = sc.category_id
        WHERE sc.email = (SELECT auth.jwt()->>'email')
    )
    OR
    -- User owns any of this bookmark's categories (via junction table)
    id IN (
        SELECT bc.bookmark_id
        FROM public.bookmark_categories bc
        INNER JOIN public.categories c ON bc.category_id = c.id
        WHERE c.user_id = (SELECT auth.uid())
    )
);

-- Update documentation
COMMENT ON POLICY "user_access_own_bookmarks" ON public.everything IS
'Allows users to access: (1) their own bookmarks, (2) all bookmarks in categories shared with them as collaborators (via junction table), (3) all bookmarks in categories they own (via junction table). Updated for many-to-many category relationship.';

-- 3. Drop index on category_id
DROP INDEX IF EXISTS idx_everything_category_id;

-- 4. Drop foreign key constraints
ALTER TABLE public.everything DROP CONSTRAINT IF EXISTS bookmarks_category_id_fkey;
ALTER TABLE public.everything DROP CONSTRAINT IF EXISTS everything_category_id_fkey;

-- 5. Drop the column
ALTER TABLE public.everything DROP COLUMN IF EXISTS category_id;

COMMIT;
